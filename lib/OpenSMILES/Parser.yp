# Header section

%{

use warnings;

use Graph::Undirected;

%}

%%

# Rules section

# The top-level 'filter' rule

smiles: chain ;

chain: atom
        { return { first => $_[1], last => $_[1] } }
     | chain atom
        {
            $_[0]->{USER}{GRAPH}->add_edge( $_[1]->{last}, $_[2] );
            return { first => $_[1]->{first}, last => $_[2] };
        }
     ;

atom: aliphatic_organic
        {
            my $atom = { symbol => $_[1] };
            $_[0]->{USER}{GRAPH}->add_vertex( $atom );
            return $atom;
        }
    | aromatic_organic
        {
            my $atom = { symbol => $_[1] };
            $_[0]->{USER}{GRAPH}->add_vertex( $atom );
            return $atom;
        }
    | bracket_atom
    | atom '(' chain ')'
        {
            $_[0]->{USER}{GRAPH}->add_edge( $_[1], $_[2]->{first} );
        }
    | atom digit
        { $_[0]->_add_ring_bond( $_[1], $_[2] ) }
    | atom '%' digit digit
        { $_[0]->_add_ring_bond( $_[1], $_[3] . $_[4] ) }
    ;

bracket_atom_incomplete: '[' number symbol
                                {
                                    my $atom = {
                                                 isotope => $_[2],
                                                 symbol  => $_[3],
                                               };
                                    $_[0]->{USER}{GRAPH}->add_vertex( $atom );
                                    return $atom;
                                }
                       | '[' symbol
                                {
                                    my $atom = {
                                                 symbol  => $_[2],
                                               };
                                    $_[0]->{USER}{GRAPH}->add_vertex( $atom );
                                    return $atom;
                                }
                       ;

bracket_atom: bracket_atom_incomplete ']'
            | bracket_atom_incomplete class ']'
                { $_[1]->{class}  = $_[2] }
            | bracket_atom_incomplete charge ']'
                { $_[1]->{charge} = $_[2] }
            | bracket_atom_incomplete charge class ']'
                { $_[1]->{charge} = $_[2]; $_[1]->{class} = $_[3] }
            | bracket_atom_incomplete hcount ']'
                { $_[1]->{hydrogens} = $_[2] }
            | bracket_atom_incomplete hcount class ']'
                { $_[1]->{hydrogens} = $_[2]; $_[1]->{class} = $_[3] }
            | bracket_atom_incomplete hcount charge ']'
                { $_[1]->{hydrogens} = $_[2]; $_[1]->{charge} = $_[3] }
            | bracket_atom_incomplete hcount charge class ']'
                { $_[1]->{hydrogens} = $_[2]; $_[1]->{charge} = $_[3]; $_[1]->{class} = $_[4] }
            | bracket_atom_incomplete chiral ']'
                { $_[1]->{chirality} = $_[2] }
            | bracket_atom_incomplete chiral class ']'
                { $_[1]->{chirality} = $_[2]; $_[1]->{class} = $_[3] }
            | bracket_atom_incomplete chiral charge ']'
                { $_[1]->{chirality} = $_[2]; $_[1]->{charge} = $_[3] }
            | bracket_atom_incomplete chiral charge class ']'
                { $_[1]->{chirality} = $_[2]; $_[1]->{charge} = $_[3]; $_[1]->{class} = $_[4] }
            | bracket_atom_incomplete chiral hcount ']'
                { $_[1]->{chirality} = $_[2]; $_[1]->{hydrogens} = $_[3] }
            | bracket_atom_incomplete chiral hcount class ']'
                { $_[1]->{chirality} = $_[2]; $_[1]->{hydrogens} = $_[3]; $_[1]->{class} = $_[4] }
            | bracket_atom_incomplete chiral hcount charge ']'
                { $_[1]->{chirality} = $_[2]; $_[1]->{hydrogens} = $_[3]; $_[1]->{charge} = $_[4] }
            | bracket_atom_incomplete chiral hcount charge class ']'
                { $_[1]->{chirality} = $_[2]; $_[1]->{hydrogens} = $_[3]; $_[1]->{charge} = $_[4]; $_[1]->{class} = $_[5] }
            ;

bracket_symbol: aliphatic_organic | aromatic_organic | element_symbol | as | se ;

hcount: 'H'
            { return 1 }
      | 'H' digit
            { return int( $_[2] ) }
      ;

charge: '-'
        { return -1 }
      | '-' '-'
        { return -2 }
      | '+'
        { return  1 }
      | '+' '+'
        { return  2 }
      | '-' digit
        { return -int( $_[2] ) }
      | '-' digit digit
        { return -int( $_[2] * 10 + $_[1] ) }
      | '+' digit
        { return  int( $_[2] ) }
      | '+' digit digit
        { return  int( $_[2] * 10 + $_[1] ) }
      ;

class: ':' number
        { return $_[2] }
      ;

number: digit
        { return int( $_[1] ) }
      | number digit
        { return $_[1] * 10 + int( $_[2] ) }
      ;

digit: '0' | '1' | '2' | '3' | '4' | '5' | '6' | '7' | '8' | '9' ;

aliphatic_organic: 'B' | 'C' | 'I' | 'N' | 'O' | 'P' | 'S' | 'F'
                 | 'C' 'l'
                    { return $_[1] . $_[2] }
                 | 'B' 'r'
                    { return $_[1] . $_[2] }
                 ;

aromatic_organic: 'b' | 'c' | 'n' | 'o' | 'p' | 's' ;

symbol: aromatic_symbol | element_symbol | '*' ;

aromatic_symbol: aromatic_organic
               | 'a' 's'
                    { return $_[1] . $_[2] }
               | 's' 'e'
                    { return $_[1] . $_[2] }
               ;

element_symbol: uppercase_letter lowercase_letter
                    { return $_[1] . $_[2] }
              | uppercase_letter
              ;

uppercase_letter: 'A' | 'B' | 'C' | 'D' | 'E' | 'F' | 'G' | 'H' | 'I'
                | 'J' | 'K' | 'L' | 'M' | 'N' | 'O' | 'P' | 'Q' | 'R'
                | 'S' | 'T' | 'U' | 'V' | 'W' | 'X' | 'Y' | 'Z' ;

lowercase_letter: 'a' | 'b' | 'c' | 'd' | 'e' | 'f' | 'g' | 'h' | 'i'
                | 'j' | 'k' | 'l' | 'm' | 'n' | 'o' | 'p' | 'q' | 'r'
                | 's' | 't' | 'u' | 'v' | 'w' | 'x' | 'y' | 'z' ;

%%

# Footer section

sub _Error
{
    my( $self ) = @_;
    close $self->{USER}{FILEIN} if $self->{USER}{FILEIN};
    my $msg = "$0: syntax error at line $self->{USER}{LINENO}, " .
              "position $self->{USER}{CHARNO}";
    if( $self->YYData->{INPUT} ) {
        $self->YYData->{INPUT} =~ s/\n$//;
        die "$msg: '" . $self->YYData->{INPUT} . "'.\n";
    } else {
        die "$msg.\n";
    }
}

sub _Lexer
{
    my( $self ) = @_;

    # If the line is empty and the input is originating from the file,
    # another line is read.
    if( !$self->YYData->{INPUT} && $self->{USER}{FILEIN} ) {
        my $filein = $self->{USER}{FILEIN};
        $self->YYData->{INPUT} = <$filein>;
        $self->{USER}{LINENO} = -1 unless exists $self->{USER}{LINENO};
        $self->{USER}{LINENO}++;
        $self->{USER}{CHARNO} = 0;
    }

    $self->YYData->{INPUT} =~ s/^(\s+)//;
    $self->{USER}{CHARNO} += length( $1 ) if defined $1;

    # Chirality
    if( $self->YYData->{INPUT} =~ s/^(@(
                                        (TH|AL)[12]       |
                                        SP     [123]      |
                                        (TB|OH)[0-9]{1,2} |
                                        @?
                                        ))//x ) {
        return ( 'chiral', $1 );
    }

    my $char = substr( $self->YYData->{INPUT}, 0, 1 );
    if( $char ne '' ) {
        $self->YYData->{INPUT} = substr( $self->YYData->{INPUT}, 1 );
    }
    $self->{USER}{CHARNO}++;
    return( $char, $char );
}

sub parse
{
    my( $self, $string ) = @_;
    $self->YYData->{INPUT} = $string;
    $self->{USER}{GRAPH}     = Graph::Undirected->new;
    $self->{USER}{RINGBONDS} = {};
    $self->{USER}{LINENO} = 0;
    $self->{USER}{CHARNO} = 0;
    $self->YYParse( yylex => \&_Lexer, yyerror => \&_Error );
    return $self->{USER}{GRAPH};
}

sub _add_ring_bond
{
    my( $self, $atom, $ring_bond ) = @_;
    $ring_bond = int( $ring_bond );
    if( $self->{USER}{RINGBONDS}{$ring_bond} ) {
        $self->{USER}{GRAPH}->add_edge( $self->{USER}{RINGBONDS}{$ring_bond},
                                        $atom );
        delete $self->{USER}{RINGBONDS}{$ring_bond};
    } else {
        $self->{USER}{RINGBONDS}{$ring_bond} = $atom;
    }
}

1;
