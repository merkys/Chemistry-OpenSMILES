# Header section

%{

use warnings;

use Graph::Undirected;

%}

%%

# Rules section

# The top-level 'filter' rule

smiles: chain ;

chain: atom
        { return { first => $_[1], last => $_[1] } }
     | chain atom
        {
            $_[0]->{USER}{GRAPH}->add_edge( $_[1]->{last}, $_[2] );
            $_[1]->{last} = $_[2];
            return $_[1];
        }
     | chain bond atom
        {
            # TODO: record the bond type
            $_[0]->{USER}{GRAPH}->add_edge( $_[1]->{last}, $_[3] );
            $_[1]->{last} = $_[3];
            return $_[1];
        }
     | chain '.' atom
        { return { last => $_[3], first => $_[3] } }
     | chain '(' chain ')'
        {
            $_[0]->{USER}{GRAPH}->add_edge( $_[1]->{last}, $_[3]->{first} );
            return $_[1];
        }
     | chain '(' bond chain ')'
        {
            # TODO: record the bond type
            $_[0]->{USER}{GRAPH}->add_edge( $_[1]->{last}, $_[4]->{first} );
            return $_[1];
        }
     | chain '(' '.' chain ')'

     # According to the specification of OpenSMILES, ring bonds are
     # allowed only before the branch enumeration. However, I think this
     # is too strict.

     | chain ringbond
        {
            $_[0]->_add_ring_bond( $_[1]->{last}, $_[2] );
            return $_[1];
        }
     | chain bond ringbond
        {
            # TODO: record the bond type
            $_[0]->_add_ring_bond( $_[1]->{last}, $_[3] );
            return $_[1];
        }
     ;

bond: '-' | '=' | '#' | '$' | ':' | '/' | '\\' ;

%%

# Footer section

sub _Error
{
    my( $self ) = @_;
    close $self->{USER}{FILEIN} if $self->{USER}{FILEIN};
    my $msg = "$0: syntax error at line $self->{USER}{LINENO}, " .
              "position $self->{USER}{CHARNO}";
    if( $self->YYData->{INPUT} ) {
        $self->YYData->{INPUT} =~ s/\n$//;
        die "$msg: '" . $self->YYData->{INPUT} . "'.\n";
    } else {
        die "$msg.\n";
    }
}

sub _Lexer
{
    my( $self ) = @_;

    # If the line is empty and the input is originating from the file,
    # another line is read.
    if( !$self->YYData->{INPUT} && $self->{USER}{FILEIN} ) {
        my $filein = $self->{USER}{FILEIN};
        $self->YYData->{INPUT} = <$filein>;
        $self->{USER}{LINENO} = -1 unless exists $self->{USER}{LINENO};
        $self->{USER}{LINENO}++;
        $self->{USER}{CHARNO} = 0;
    }

    $self->YYData->{INPUT} =~ s/^(\s+)//;
    $self->{USER}{CHARNO} += length( $1 ) if defined $1;

    # Bracket atoms
    if( $self->YYData->{INPUT} =~ s/^\[ (?<isotope>[0-9]+)?
                                        (?<symbol>[A-Za-z][a-z]?|\*)
                                        (?<chirality>@(
                                         (TH|AL)[12]       |
                                         SP     [123]      |
                                         (TB|OH)[0-9]{1,2} |
                                         @?
                                         ))?
                                        (?<hcount>H[0-9]?)?
                                        (?<charge>--|\+\+|[-+][0-9]{0,2})?
                                        (:(?<class>[0-9]+))? \]//x ) {
        my $atom = { %+ };

        # Atom class is an arbitrary number, 0 by default
        $atom->{class} = exists $atom->{class} ? int $atom->{class} : 0;

        $self->{USER}{GRAPH}->add_vertex( $atom );
        return ( 'atom', $atom );
    }

    # Bracketless atoms
    if( $self->YYData->{INPUT} =~ s/^(Br|Cl|[BCINOPSFbcnops])// ) {
        my $atom = { symbol => $1 };
        $self->{USER}{GRAPH}->add_vertex( $atom );
        return ( 'atom', $atom );
    }

    # Ring bonds
    if( $self->YYData->{INPUT} =~ s/^(?:%([0-9]))([0-9])// ) {
        return ( 'ringbond', int( $1 . $2 ) );
    }

    my $char = substr( $self->YYData->{INPUT}, 0, 1 );
    if( $char ne '' ) {
        $self->YYData->{INPUT} = substr( $self->YYData->{INPUT}, 1 );
    }
    $self->{USER}{CHARNO}++;
    return( $char, $char );
}

sub parse
{
    my( $self, $string, $options ) = @_;
    $options = {} unless $options;

    $self->YYData->{INPUT} = $string;
    $self->{USER}{GRAPH}     = Graph::Undirected->new;
    $self->{USER}{RINGBONDS} = {};
    $self->{USER}{LINENO} = 0;
    $self->{USER}{CHARNO} = 0;
    $self->YYParse( yylex => \&_Lexer,
                    yyerror => \&_Error,
                    yydebug => $options->{debug} );
    return $self->{USER}{GRAPH};
}

sub _add_ring_bond
{
    my( $self, $atom, $ring_bond ) = @_;
    $ring_bond = int( $ring_bond );
    if( $self->{USER}{RINGBONDS}{$ring_bond} ) {
        $self->{USER}{GRAPH}->add_edge( $self->{USER}{RINGBONDS}{$ring_bond},
                                        $atom );
        delete $self->{USER}{RINGBONDS}{$ring_bond};
    } else {
        $self->{USER}{RINGBONDS}{$ring_bond} = $atom;
    }
}

sub _sprint_atom
{
    my( $atom ) = @_;
    return '[' . (exists $atom->{isotope}   ? $atom->{isotope}   : '') .
                 $atom->{symbol} .
                 (exists $atom->{chirality} ? $atom->{chirality} : '') .
                 (exists $atom->{hcount}    ? $atom->{hcount}    : '') .
                 (exists $atom->{charge}    ? $atom->{charge}    : '') .
                 (exists $atom->{class} && $atom->{class}
                    ? ':' . $atom->{class} : '') .
           ']';
}

1;
